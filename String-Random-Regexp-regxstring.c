/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.51 from the
 * contents of String-Random-Regexp-regxstring.xs. Do not edit this file, edit String-Random-Regexp-regxstring.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "String-Random-Regexp-regxstring.xs"
// Function name mangling!!!!!!!!!!!
// use this so that function names in object files are as
// specified in the proto

/* don't forget that we are using a C++ compiler and so these
  need to be protected else ... function-name mangling ooouuouuuuoouu :
*/

/*
our $VERSION = '1.04';
*/

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <stdio.h>
#include <stdlib.h>

/* helper func to check if SV contains undef */
int _SV_contains_undef(SV *ansv){ SvGETMAGIC(ansv); return(!SvOK(ansv)); }

#ifdef __cplusplus
} // extern "C" {
#endif

#include "harness.h"

/* Perl redefines libc's malloc() and free().
   When memory is allocated externally,
   we must use free() which is Perl's.
   Do the same for malloc() if you need to use it.
   Not any more with this:
*/
void MyFree( void *p ) {
#undef free
    free( p );
}

/* NOTE: the ... in the function signature below
          denotes optional; parameters: int debug
*/

#line 57 "String-Random-Regexp-regxstring.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 201 "String-Random-Regexp-regxstring.c"

XS_EUPXS(XS_String__Random__Regexp__regxstring_generate_random_strings_xs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_String__Random__Regexp__regxstring_generate_random_strings_xs)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "regx_SV, N, ...");
    {
#line 56 "String-Random-Regexp-regxstring.xs"
	STRLEN regxstr_len;
	int debug = 0; // default value for optional parameter, see above
#line 213 "String-Random-Regexp-regxstring.c"
	AV *	RETVAL;
	SV *	regx_SV = ST(0)
;
	int	N = (int)SvIV(ST(1))
;
#line 59 "String-Random-Regexp-regxstring.xs"
	// TODO: try using croak
	if( _SV_contains_undef(regx_SV) ){ fprintf(stderr, "generate_random_strings_xs() : error, input regexp string can not be undefined.\n"); XSRETURN_UNDEF; }
	if( N < 1 ){ fprintf(stderr, "generate_random_strings_xs() : error, the number of strings to return must be a positive integer (and not %d).\n", N); XSRETURN_UNDEF; }
#line 223 "String-Random-Regexp-regxstring.c"
#line 63 "String-Random-Regexp-regxstring.xs"
	if( items > 2 ){
		// we have the optional parameter
		debug = SvIV(ST(2));
	}

	char *regxstr = SvUTF8(regx_SV)
		? SvPVutf8(regx_SV, regxstr_len)
		: SvPVbyte(regx_SV, regxstr_len)
	;
	/* this is in harness.cpp */
	/* we need to free char **results when done
	   they were allocated in harness.cpp with malloc()
	*/
	char **results = regxstring_generate_random_strings_from_regex(
		regxstr,
		N,
		debug
	);
	if( results == NULL ){ fprintf(stderr, "generate_random_strings_xs() : error, call to 'regxstring_generate_random_strings_from_regex()' has failed for the regex '%s' and N=%d.\n", regxstr, N); XSRETURN_UNDEF; }

        RETVAL = (AV*)sv_2mortal((SV*)newAV());
        for(int i=0;i<N;i++){
		/* newSVpvn_flags() and newSVpvn() create a new Perl string from each results string
		   So, we can safely free results[i]
		*/
		av_push(RETVAL, newSVpvn_flags(results[i], strlen(results[i]), SVf_UTF8));
		if( results[i] != NULL ) MyFree(results[i]);
        }
	MyFree(results);
	// end of program

#line 256 "String-Random-Regexp-regxstring.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C" {
#endif
XS_EXTERNAL(boot_String__Random__Regexp__regxstring); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_String__Random__Regexp__regxstring)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("String::Random::Regexp::regxstring::generate_random_strings_xs", XS_String__Random__Regexp__regxstring_generate_random_strings_xs, file, "@");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

#ifdef __cplusplus
}
#endif
